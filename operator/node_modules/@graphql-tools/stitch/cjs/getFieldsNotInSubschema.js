"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldsNotInSubschema = void 0;
const graphql_1 = require("graphql");
const delegate_1 = require("@graphql-tools/delegate");
const utils_1 = require("@graphql-tools/utils");
function getFieldsNotInSubschema(schema, stitchingInfo, gatewayType, subschemaType, fieldNodes, fragments, variableValues) {
    let { fields: subFieldNodesByResponseKey, patches } = (0, utils_1.collectSubFields)(schema, fragments, variableValues, gatewayType, fieldNodes);
    let mapChanged = false;
    // Collect deferred fields
    if (patches.length) {
        subFieldNodesByResponseKey = new Map(subFieldNodesByResponseKey);
        for (const patch of patches) {
            for (const [responseKey, fields] of patch.fields) {
                if (!mapChanged) {
                    subFieldNodesByResponseKey = new Map(subFieldNodesByResponseKey);
                    mapChanged = true;
                }
                const existingSubFieldNodes = subFieldNodesByResponseKey.get(responseKey);
                if (existingSubFieldNodes) {
                    existingSubFieldNodes.push(...fields);
                }
                else {
                    subFieldNodesByResponseKey.set(responseKey, fields);
                }
            }
        }
    }
    const fieldsNotInSchema = new Set();
    if ((0, graphql_1.isAbstractType)(gatewayType)) {
        fieldsNotInSchema.add({
            kind: graphql_1.Kind.FIELD,
            name: {
                kind: graphql_1.Kind.NAME,
                value: '__typename',
            },
        });
        for (const possibleType of schema.getPossibleTypes(gatewayType)) {
            const { fields: subFieldNodesOfPossibleType, patches } = (0, utils_1.collectSubFields)(schema, fragments, variableValues, possibleType, fieldNodes);
            for (const patch of patches) {
                for (const [responseKey, fields] of patch.fields) {
                    if (!mapChanged) {
                        subFieldNodesByResponseKey = new Map(subFieldNodesByResponseKey);
                        mapChanged = true;
                    }
                    const existingSubFieldNodes = subFieldNodesByResponseKey.get(responseKey);
                    if (existingSubFieldNodes) {
                        existingSubFieldNodes.push(...fields);
                    }
                    else {
                        subFieldNodesByResponseKey.set(responseKey, fields);
                    }
                }
            }
            for (const [responseKey, subFieldNodes] of subFieldNodesOfPossibleType) {
                if (!mapChanged) {
                    subFieldNodesByResponseKey = new Map(subFieldNodesByResponseKey);
                    mapChanged = true;
                }
                const existingSubFieldNodes = subFieldNodesByResponseKey.get(responseKey);
                if (existingSubFieldNodes) {
                    existingSubFieldNodes.push(...subFieldNodes);
                }
                else {
                    subFieldNodesByResponseKey.set(responseKey, subFieldNodes);
                }
            }
        }
    }
    // TODO: Verify whether it is safe that extensions always exists.
    const fieldNodesByField = stitchingInfo?.fieldNodesByField;
    const shouldAdd = (fieldType, selection) => !fieldNodesByField?.[fieldType.name]?.[selection.name.value];
    const fields = subschemaType.getFields();
    for (const [, subFieldNodes] of subFieldNodesByResponseKey) {
        const fieldName = subFieldNodes[0].name.value;
        if (!fields[fieldName]) {
            for (const subFieldNode of subFieldNodes) {
                fieldsNotInSchema.add(subFieldNode);
            }
        }
        else {
            const field = fields[fieldName];
            for (const subFieldNode of subFieldNodes) {
                const unavailableFields = (0, delegate_1.extractUnavailableFields)(schema, field, subFieldNode, shouldAdd);
                if (unavailableFields.length) {
                    fieldsNotInSchema.add({
                        ...subFieldNode,
                        selectionSet: {
                            kind: graphql_1.Kind.SELECTION_SET,
                            selections: unavailableFields,
                        },
                    });
                }
            }
        }
        let addedSubFieldNodes = false;
        const fieldNodesByFieldForType = fieldNodesByField?.[gatewayType.name];
        const visitedFieldNames = new Set();
        if (fieldNodesByFieldForType) {
            addMissingRequiredFields({
                fieldName,
                fields,
                fieldsNotInSchema,
                visitedFieldNames,
                onAdd: () => {
                    if (!addedSubFieldNodes) {
                        for (const subFieldNode of subFieldNodes) {
                            fieldsNotInSchema.add(subFieldNode);
                        }
                        addedSubFieldNodes = true;
                    }
                },
                fieldNodesByField: fieldNodesByFieldForType,
            });
        }
    }
    return Array.from(fieldsNotInSchema);
}
exports.getFieldsNotInSubschema = getFieldsNotInSubschema;
function addMissingRequiredFields({ fieldName, fields, fieldsNotInSchema, onAdd, fieldNodesByField, visitedFieldNames, }) {
    if (visitedFieldNames.has(fieldName)) {
        return;
    }
    visitedFieldNames.add(fieldName);
    const fieldNodesForField = fieldNodesByField?.[fieldName];
    if (fieldNodesForField) {
        for (const fieldNode of fieldNodesForField) {
            if (fieldNode.name.value !== '__typename' && !fields[fieldNode.name.value]) {
                onAdd();
                fieldsNotInSchema.add(fieldNode);
                addMissingRequiredFields({
                    fieldName: fieldNode.name.value,
                    fields,
                    fieldsNotInSchema,
                    onAdd,
                    fieldNodesByField,
                    visitedFieldNames,
                });
            }
        }
    }
}
